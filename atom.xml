<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Adison&#39;s Notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-19T21:56:10.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Adison</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《深入理解java虚拟机》阅读笔记</title>
    <link href="http://yoursite.com/2016/08/20/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/08/20/《深入理解java虚拟机》阅读笔记/</id>
    <published>2016-08-19T21:20:10.000Z</published>
    <updated>2016-08-19T21:56:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1.运行时数据区域"></a>1.运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。<a id="more"></a>根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/0063dNt1jw1f6zs6drlusj31g814sthk.jpg" alt="运行时数据区域"></p>
<h4 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1. 程序计数器"></a>1.1. 程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>
<p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="1-2-Java虚拟机栈"><a href="#1-2-Java虚拟机栈" class="headerlink" title="1.2. Java虚拟机栈"></a>1.2. Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame[1]）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h4 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3.本地方法栈"></a>1.3.本地方法栈</h4><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h4 id="1-4-Java堆"><a href="#1-4-Java堆" class="headerlink" title="1.4.Java堆"></a>1.4.Java堆</h4><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<h4 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5.方法区"></a>1.5.方法区</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h4 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6.运行时常量池"></a>1.6.运行时常量池</h4><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<h3 id="2-虚拟机对象探秘"><a href="#2-虚拟机对象探秘" class="headerlink" title="2. 虚拟机对象探秘"></a>2. 虚拟机对象探秘</h3><h4 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1. 对象的创建"></a>2.1. 对象的创建</h4><p>对象所需内存的大小在类加载完成后便可以完全确定。</p>
<h4 id="2-2-对象的访问定位"><a href="#2-2-对象的访问定位" class="headerlink" title="2.2. 对象的访问定位"></a>2.2. 对象的访问定位</h4><p>目前主流的访问方式有使用句柄和直接指针两种。</p>
<p>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如图所示。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/0063dNt1jw1f6zs6quu0qj31kw0qxjwa.jpg" alt="句柄访问"></p>
<p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，如图所示。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/0063dNt1jw1f6zs6rjpsjj31kw0s842x.jpg" alt="指针访问"></p>
<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的。</p>
<h3 id="3-垃圾收集器与内存分配策略"><a href="#3-垃圾收集器与内存分配策略" class="headerlink" title="3. 垃圾收集器与内存分配策略"></a>3. 垃圾收集器与内存分配策略</h3><h4 id="3-1-对象已死吗"><a href="#3-1-对象已死吗" class="headerlink" title="3.1.对象已死吗"></a>3.1.对象已死吗</h4><ul>
<li><p>引用计数算法</p>
<p>很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<blockquote>
<p>它很难解决对象之间相互循环引用的问题。</p>
</blockquote>
</li>
<li><p>可达性分析算法</p>
<p>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
</ul>
</li>
</ul>
<ul>
<li>方法区中类静态属性引用的对象。</li>
</ul>
<ul>
<li>方法区中常量引用的对象。</li>
</ul>
<ul>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
<h4 id="3-2-生存还是死亡"><a href="#3-2-生存还是死亡" class="headerlink" title="3.2. 生存还是死亡"></a>3.2. 生存还是死亡</h4><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize（）方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
<p>建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。</p>
<h4 id="3-3-无用的类"><a href="#3-3-无用的类" class="headerlink" title="3.3.无用的类"></a>3.3.无用的类</h4><p>类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
</ul>
<ul>
<li>加载该类的ClassLoader已经被回收。</li>
</ul>
<ul>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h4 id="3-4-垃圾收集算法"><a href="#3-4-垃圾收集算法" class="headerlink" title="3.4.垃圾收集算法"></a>3.4.垃圾收集算法</h4><blockquote>
<p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
</blockquote>
<h5 id="3-4-1-标记-清除算法"><a href="#3-4-1-标记-清除算法" class="headerlink" title="3.4.1.标记-清除算法"></a>3.4.1.标记-清除算法</h5><p>如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记—清除算法的执行过程如图所示。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/0063dNt1jw1f6zs6v0nebj31ew0yy783.jpg" alt="标记-清除算法"></p>
<h5 id="3-4-2-复制算法"><a href="#3-4-2-复制算法" class="headerlink" title="3.4.2.复制算法"></a>3.4.2.复制算法</h5><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。复制算法的执行过程如图所示。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/0063dNt1jw1f6zs6vpduzj31e20yyadz.jpg" alt="复制算法"></p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）</p>
<blockquote>
<p>分配担保:如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
</blockquote>
<h5 id="3-4-3-标记-整理算法"><a href="#3-4-3-标记-整理算法" class="headerlink" title="3.4.3.标记-整理算法"></a>3.4.3.标记-整理算法</h5><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图所示。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/0063dNt1jw1f6zs6wfrvxj31bm0x2n0p.jpg" alt="标记-整理算法"></p>
<h4 id="3-5-内存分配规则"><a href="#3-5-内存分配规则" class="headerlink" title="3.5.内存分配规则"></a>3.5.内存分配规则</h4><h5 id="3-5-1-对象优先在Eden分配"><a href="#3-5-1-对象优先在Eden分配" class="headerlink" title="3.5.1.对象优先在Eden分配"></a>3.5.1.对象优先在Eden分配</h5><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<ul>
<li><p>新生代GC（Minor GC）</p>
<p>指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
</li>
</ul>
<ul>
<li><p>老年代GC（Major GC/Full GC）</p>
<p>指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。 </p>
</li>
</ul>
<h5 id="3-5-2-大对象直接进入老年代"><a href="#3-5-2-大对象直接进入老年代" class="headerlink" title="3.5.2.大对象直接进入老年代"></a>3.5.2.大对象直接进入老年代</h5><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>
<h5 id="3-5-3-长期存活的对象将进入老年代"><a href="#3-5-3-长期存活的对象将进入老年代" class="headerlink" title="3.5.3.长期存活的对象将进入老年代"></a>3.5.3.长期存活的对象将进入老年代</h5><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</p>
<h5 id="3-5-4-动态对象年龄判定"><a href="#3-5-4-动态对象年龄判定" class="headerlink" title="3.5.4.动态对象年龄判定"></a>3.5.4.动态对象年龄判定</h5><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h5 id="3-5-5-空间分配担保"><a href="#3-5-5-空间分配担保" class="headerlink" title="3.5.5.空间分配担保"></a>3.5.5.空间分配担保</h5><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>
<h3 id="4-虚拟机类加载机制"><a href="#4-虚拟机类加载机制" class="headerlink" title="4.虚拟机类加载机制"></a>4.虚拟机类加载机制</h3><blockquote>
<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
</blockquote>
<h4 id="4-1-类的生命周期"><a href="#4-1-类的生命周期" class="headerlink" title="4.1.类的生命周期"></a>4.1.类的生命周期</h4><p> 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如图所示。 </p>
<p><img src="http://ww3.sinaimg.cn/mw690/0063dNt1jw1f6zs6xdztjj31kw0m978d.jpg" alt="类的生命周期"></p>
<h4 id="4-2-类加载器"><a href="#4-2-类加载器" class="headerlink" title="4.2.类加载器"></a>4.2.类加载器</h4><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<h5 id="4-2-1-双亲委派模型"><a href="#4-2-1-双亲委派模型" class="headerlink" title="4.2.1.双亲委派模型"></a>4.2.1.双亲委派模型</h5><p>绝大部分Java程序都会使用到以下3种系统提供的类加载器:</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader）</p>
<p>这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）</p>
<p>这个加载器由sun.misc.Launcher $ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）</p>
<p>这个类加载器由sun.misc.Launcher $App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。它负责加载用“户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如图所示。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/0063dNt1jw1f6zs6yx6eij3148160q8e.jpg" alt="双亲委派模型"></p>
<p>上图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<h3 id="5-Java内存模型与线程"><a href="#5-Java内存模型与线程" class="headerlink" title="5.Java内存模型与线程"></a>5.Java内存模型与线程</h3><h4 id="5-1-主内存与工作内存"><a href="#5-1-主内存与工作内存" class="headerlink" title="5.1.主内存与工作内存"></a>5.1.主内存与工作内存</h4><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/0063dNt1jw1f6zs708ki0j31kw0s2jw6.jpg" alt="主内存与工作内存"></p>
<h4 id="5-2-内存间交互操作"><a href="#5-2-内存间交互操作" class="headerlink" title="5.2.内存间交互操作"></a>5.2.内存间交互操作</h4><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p>
<ul>
<li><p>lock（锁定）</p>
<p>作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</p>
</li>
</ul>
<ul>
<li><p>unlock（解锁）</p>
<p>作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
</li>
</ul>
<ul>
<li><p>read（读取）</p>
<p>作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</p>
</li>
</ul>
<ul>
<li><p>load（载入）</p>
<p>作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
</li>
</ul>
<ul>
<li><p>use（使用）</p>
<p>作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</p>
</li>
<li><p>assign（赋值）</p>
<p>作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</li>
<li><p>store（存储）</p>
<p>作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</p>
</li>
<li><p>write（写入）</p>
<p>作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</p>
</li>
</ul>
<p><strong>Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</strong></p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ul>
<h4 id="5-3-对于volatile型变量的特殊规则"><a href="#5-3-对于volatile型变量的特殊规则" class="headerlink" title="5.3.对于volatile型变量的特殊规则"></a>5.3.对于volatile型变量的特殊规则</h4><blockquote>
<p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。</p>
</blockquote>
<p>当一个变量定义为volatile之后，它将具备两种特性:</p>
<ul>
<li><p>保证此变量对所有线程的可见性</p>
<p>这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。</p>
<p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
</li>
<li><p>禁止指令重排序优化</p>
<p>普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义。</p>
</li>
</ul>
<p>####5.4.原子性、可见性与有序性</p>
<p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，我们逐个来看一下哪些操作实现了这3个特性。</p>
<ul>
<li><p>原子性（Atomicity</p>
<p>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p>
</li>
<li><p>可见性（Visibility）</p>
<p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。上文在讲解volatile变量的时候我们已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p>
<p>除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。</p>
</li>
<li><p>有序性（Ordering）</p>
<p>Java内存模型的有序性在前面讲解volatile时也详细地讨论过了，Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p>
<p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
<blockquote>
<p>synchronized注意：首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。第12章讲过，Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块（如被synchronized修饰的getter（）或setter（）方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。所以synchronized是Java语言中一个重量级（Heavyweight）的操作，有经验的程序员都会在确实必要的情况下才使用这种操作。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中。</p>
</blockquote>
</li>
</ul>
<h4 id="5-5-先行发生原则"><a href="#5-5-先行发生原则" class="headerlink" title="5.5.先行发生原则"></a>5.5.先行发生原则</h4><p>如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将会变得很烦琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”（happens-before）的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>“天然的”先行发生关系:</p>
<ul>
<li><p>程序次序规则（Program Order Rule）</p>
<p>在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p>
</li>
<li><p>管程锁定规则（Monitor Lock Rule）</p>
<p>一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</p>
</li>
<li><p>volatile变量规则（Volatile Variable Rule）</p>
<p>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</p>
</li>
<li><p>线程启动规则（Thread Start Rule）</p>
<p>Thread对象的start（）方法先行发生于此线程的每一个动作。</p>
</li>
<li><p>线程终止规则（Thread Termination Rule）</p>
<p>线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。</p>
</li>
<li><p>线程中断规则（Thread Interruption Rule）</p>
<p>对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。</p>
</li>
<li><p>对象终结规则（Finalizer Rule）</p>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。</p>
</li>
<li><p>传递性（Transitivity)</p>
<p>如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p>
<blockquote>
<p>时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-运行时数据区域&quot;&gt;&lt;a href=&quot;#1-运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;1.运行时数据区域&quot;&gt;&lt;/a&gt;1.运行时数据区域&lt;/h3&gt;&lt;p&gt;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。
    
    </summary>
    
      <category term="阅读笔记" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Android 调试技巧</title>
    <link href="http://yoursite.com/2016/08/20/Android-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2016/08/20/Android-调试技巧/</id>
    <published>2016-08-19T21:18:07.000Z</published>
    <updated>2016-08-19T22:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名码农，代码调试是一项不可或缺的工作，过程中总能发现一下能提高效率、有用的小技巧，此文特总结一些工作用到的一些调试技巧。</p>
<a id="more"></a>
<h3 id="Debug技巧"><a href="#Debug技巧" class="headerlink" title="Debug技巧"></a>Debug技巧</h3><p>断点debug大家都会使用，但除了单步调试之外，用过条件断点，日志断点么，一些很有用的debug技巧或许你不知道。。</p>
<ul>
<li>临时断点</li>
</ul>
<p>顾名思义，临时性断点，在第一次触发后会自动被移除</p>
<p><img src="http://ww4.sinaimg.cn/bmiddle/0063dNt1jw1f01v51zx0cj30dc08yq3i.jpg" alt="临时断点"></p>
<blockquote>
<p>触发键：Alt + 鼠标左键</p>
</blockquote>
<ul>
<li>禁用断点</li>
</ul>
<p>当你需要临时禁用一些断点，但不想下一次再重新创建这些断点的时候有用</p>
<p><img src="http://ww4.sinaimg.cn/bmiddle/0063dNt1jw1f01ve33xztj30k807475a.jpg" alt="禁用断点"></p>
<blockquote>
<p>触发键：Alt + 鼠标左键</p>
</blockquote>
<ul>
<li>计算表达式</li>
</ul>
<p>当你需要临时改变某个变量的值或者查看其内部方法返回值时很有用</p>
<p><img src="http://ww3.sinaimg.cn/bmiddle/0063dNt1gw1f01vm1upudj30ta0t4dha.jpg" alt="计算表达式"></p>
<blockquote>
<p>触发键：Alt + F8</p>
</blockquote>
<ul>
<li>计算表达式</li>
</ul>
<p>当你需要临时改变某个变量的值或者查看其内部方法返回值时很有用</p>
<p><img src="http://ww3.sinaimg.cn/bmiddle/0063dNt1gw1f01vm1upudj30ta0t4dha.jpg" alt="计算表达式"></p>
<blockquote>
<p>触发键：Alt + F8</p>
</blockquote>
<ul>
<li>检查表达式</li>
</ul>
<p>不需要打开表达式计算框就可以看到计算结果</p>
<p><img src="http://ww3.sinaimg.cn/bmiddle/0063dNt1jw1f01vyfr1e4j30t204kwfp.jpg" alt="检查表达式"></p>
<blockquote>
<p>触发键： 选中表达式，Alt + 鼠标左键</p>
</blockquote>
<ul>
<li>条件断点</li>
</ul>
<p>在特定条件下才断点</p>
<p><img src="http://ww3.sinaimg.cn/bmiddle/0063dNt1jw1f01w5s68plj30py0a63zo.jpg" alt="条件断点"></p>
<blockquote>
<p>触发键：鼠标右键点击断点</p>
</blockquote>
<ul>
<li>日志断点</li>
</ul>
<p>厌倦了每次输出一个log都得重新发布项目？试试日志断点，无痛解决你的问题</p>
<p><img src="http://ww2.sinaimg.cn/bmiddle/0063dNt1jw1f01wj9xzkwj30xa0ke40r.jpg" alt="日志断点"></p>
<blockquote>
<p>触发键：鼠标右键点击断点后–&gt;more–&gt;勾掉suspend 属性（应用不挂起）–&gt;填上想要输出的日志信息</p>
</blockquote>
<h3 id="ADB技巧"><a href="#ADB技巧" class="headerlink" title="ADB技巧"></a>ADB技巧</h3><p>adb作为android开发一个常用的工具，神马install,uninstall,push,pull命令就不用说了，它还有很多有用命令。。</p>
<ul>
<li>删除文件夹及其下面所有文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell rm -r /sdcard/xx/</div></pre></td></tr></table></figure>
<ul>
<li>应用程序恢复初始状态:清除数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell pm clear com.xx.xx(包名)</div></pre></td></tr></table></figure>
<ul>
<li>测试软件的稳定性、健壮</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell monkey --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --ignore-native-crashes -s 100 -v -v --throttle 100 -p com.xx.xx(包名) 10000 &gt; ~/Downloads/monkey_test.txt</div></pre></td></tr></table></figure>
<ul>
<li>获取设备分辨率</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">adb shell wm size</div><div class="line">或者</div><div class="line">adb shell dumpsys display | grep  DisplayDeviceInfo</div></pre></td></tr></table></figure>
<blockquote>
<p>adb shell dumpsys： 个人觉得是最有用的adb命令，默认打印出当前系统所有service信息，在后面可加上具体的服务名。  需要列出当前运行的服务，可运行：  <code>adb shell dumpsys | grep DUMP</code></p>
</blockquote>
<ul>
<li>获取内存信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys meminfo</div></pre></td></tr></table></figure>
<ul>
<li>要获取具体应用的内存信息，可加上包名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys meminfo com.xx.xx</div></pre></td></tr></table></figure>
<blockquote>
<p>通常来说： Heap Free &gt; Pss Total &gt; Private Dirty</p>
</blockquote>
<p>具体参数说明，可以参考 <a href="http://developer.android.com/intl/zh-cn/tools/debugging/debugging-memory.html" target="_blank" rel="external">官方文档</a></p>
<ul>
<li>列出系统所有属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">adb shell getprop</div><div class="line"></div><div class="line">&gt; 获取分辨率密度：adb shell getprop |grep ro.sf.lcd_density</div><div class="line"></div><div class="line">&gt; 获取系统版本：  adb shell getprop |grep ro.build.version.release</div></pre></td></tr></table></figure>
<ul>
<li>查看Activity任务栈</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys activity activities | sed -En -e &apos;/Running activities/,/Run #0/p&apos;</div></pre></td></tr></table></figure>
<ul>
<li>启动默认浏览器打开一个网页</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am start -a android.intent.action.VIEW -d http://baidu.com</div></pre></td></tr></table></figure>
<h3 id="网络调试技巧"><a href="#网络调试技巧" class="headerlink" title="网络调试技巧"></a>网络调试技巧</h3><p>日常开发中，不可避免的需要联网操作，这可能就需要懂一些网络调试技巧了，而抓包就是最基本的网络调试技巧。。</p>
<h4 id="HTTP或HTTPS抓包-finddler-windows-charles"><a href="#HTTP或HTTPS抓包-finddler-windows-charles" class="headerlink" title="HTTP或HTTPS抓包( finddler(windows)/charles)"></a>HTTP或HTTPS抓包( finddler(windows)/charles)</h4><p>这个就不多说了，网上教程一大堆。。</p>
<p><a href="http://jingyan.baidu.com/article/335530da80e70319ca41c37c.html?qq-pf-to=pcqq.group" target="_blank" rel="external">charles使用教程</a></p>
<p><a href="http://www.cnblogs.com/TankXiao/p/3063871.html" target="_blank" rel="external">finddler使用教程</a></p>
<h4 id="TCP非实时抓包（tcpdump）"><a href="#TCP非实时抓包（tcpdump）" class="headerlink" title="TCP非实时抓包（tcpdump）"></a>TCP非实时抓包（tcpdump）</h4><p>前提：Root</p>
<ol>
<li><p>从 <a href="http://www.tcpdump.org/#latest-release" target="_blank" rel="external">这里</a> 下载 tcpdump</p>
</li>
<li><p>将 tcpdump 放入手机： <code>adb push ~/tcpdump /data/local/tcpdump</code></p>
</li>
<li><p>将 tcpdump 的权限变为可执行：<code>chmod +x tcpdump</code></p>
</li>
<li><p>开始抓包： </p>
<blockquote>
<p><code>/data/local/tcpdump -vv -s 0 -w /mnt/sdcard/pcapture.pcap</code>。其中 “-s 0” 表示每个包都抓取全部长度，而不是部分长度；”-w /mnt/sdcard/pcapture.pcap” 表示抓取的包写入指定文件；”-vv” 表示显示多一些信息，如果要显示更多信息可以用 “-vvv”</p>
</blockquote>
</li>
<li><p>按下 “contrl+c” 结束抓包。</p>
</li>
<li><p>将”/mnt/sdcard/pcapture.pcap” 移到电脑上： <code>adb pull /mnt/sdcard/pcapture.pcap &lt;指定目录&gt;</code></p>
</li>
<li><p>通过 Wireshark 或者charles进行分析。</p>
</li>
</ol>
<h4 id="TCP实时抓包-wireshark＋tcpdump"><a href="#TCP实时抓包-wireshark＋tcpdump" class="headerlink" title="TCP实时抓包(wireshark＋tcpdump)"></a>TCP实时抓包(wireshark＋tcpdump)</h4><p><a href="http://www.phonesdevelopers.com/1693228/" target="_blank" rel="external">参考文章</a></p>
<p>基本思路：</p>
<p><img src="http://i.imgur.com/ffV4vq4.png" alt="基本思路"></p>
<ul>
<li><p>手机开始抓包:在 adb shell 中运行 <code>/data/local/tcpdump -n -s 0 -w - | nc -l -p 12345</code></p>
</li>
<li><p>将手机抓的包传送到电脑的 Wireshark 中:另开一个终端运行 <code>adb forward tcp:12345 tcp:12345 &amp;&amp; nc 127.0.0.1 12345 | /Applications/Wireshark.app/Contents/MacOS/wireshark -k -S -i -</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名码农，代码调试是一项不可或缺的工作，过程中总能发现一下能提高效率、有用的小技巧，此文特总结一些工作用到的一些调试技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="调试技巧" scheme="http://yoursite.com/tags/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android内存泄漏 ——检测、解决和避免</title>
    <link href="http://yoursite.com/2016/08/20/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E2%80%94%E2%80%94%E6%A3%80%E6%B5%8B%E3%80%81%E8%A7%A3%E5%86%B3%E5%92%8C%E9%81%BF%E5%85%8D/"/>
    <id>http://yoursite.com/2016/08/20/Android内存泄漏-——检测、解决和避免/</id>
    <published>2016-08-19T21:15:26.000Z</published>
    <updated>2016-08-19T22:01:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为开发人员，在我们的日常开发中，为了构建更好的应用程序，我们需要考虑很多事情以保证应用运行在正轨上，其中之一是要确保我们的应用程序不会崩溃。应用崩溃的一个常见原因是内存泄漏。这方面的问题可以以各种形式表现出来。在大多数情况下，我们看到内存使用率稳步上升，直到应用程序不能分配更多的资源，并不可避免地崩溃。在Java中这往往导致一个<strong>OutOfMemoryException异常</strong>被抛出。在某些罕见的情况下，泄露的类甚至可以逗留很长时间来接收已注册的回调，这会导致一些非常奇怪的错误，并往往抛出臭名昭著的<strong>IllegalStateException异常</strong>。</p>
<p>为了帮助他人在代码分析上减少花费时间，我将介绍内存泄漏的几个例子，阐述在Android Studio中如何检查它们，当然最重要的是如何将其解决。</p>
<a id="more"></a>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>在这篇文章中的代码示例的目的是为了促进大家对内存管理有更深的了解，特别是在java。其通用的体系结构，线程管理和代码示例的 HTTP 请求处理在真实的生产环境并不是理想的，这些示例仅仅为了说明一个问题：在Android中，内存泄漏是一件要考虑的事情。</p>
<h4 id="监听器注册"><a href="#监听器注册" class="headerlink" title="监听器注册"></a>监听器注册</h4><p>这真的不应该是个问题，但我经常看到各种注册方法的调用，但他们对应的注销方法却无处可寻。这是泄漏的潜在来源，因为这些方法明确设计成互相抵消。如果没有调用注销方法，被引用的对象已经被终止后，监听实例可能会持有该对象很长的时间，从而导致泄漏内存。在Android中，如果该对象是一个Activity对象，是特别麻烦的，因为他们往往拥有大量的数据。让我告诉你，可能是什么样子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaksActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LocationListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> LocationManager locationManager;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_leaks);</div><div class="line">        locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);</div><div class="line">        locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER,</div><div class="line">                TimeUnit.MINUTES.toMillis(<span class="number">5</span>), <span class="number">100</span>, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Listener implementation omitted</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，我们让Android的 <a href="https://developer.android.com/reference/android/location/LocationManager.html" target="_blank" rel="external"><strong>LocationManager</strong></a>通知我们位置更新。我们所需要做的就是获取系统服务本身和设置一个回调来接收更新。在这里，我们在Activity中实现了位置监听接口，这意味着<strong>LocationManager</strong>将持有该Activity的引用。现在，如果该设备被旋转，新的Activity将被创建并取代已经注册位置更新接口的旧的Activity。由于系统服务存活时间肯定比任何Activity都要长，<strong>LocationManager</strong>仍然持有以前的Activity的引用，这使GC不可能回收依赖于以前的Activity的资源，从而导致内存泄漏。如果反复旋转设备，将导致大量的不可回收的Activity填满内存，最终导致<strong>OutOfMemoryException异常</strong>。</p>
<p>但为了解决内存泄漏，我们首先必须要能够找到它。幸运的是，<strong>Android Studio</strong>有一个叫做 <strong>Android Monitor</strong>的内置工具，我们可以用它来 观察除应用内存使用情况。我们需要做的仅仅是打开Android Monitor 并转到对应tab，看看使用了多少内存和内存实时分配情况。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/0063dNt1jw1f6zscmk95cj30no0hodi4.jpg" alt="1-3R36AJUjtdBArkIxPuED3g.png"></p>
<p>任何导致资源分配的交互都在这里反映出来，使之成为跟踪应用程序的资源使用情况的理想场所。为了找到内存泄露，当我们怀疑在某个时间点内存被泄露时，我们需要知道在该时间点包含了那些内存。对于这个特殊的例子，我们所要做的就是启动我们的应用程序，然后旋转设备一次，然后调用<strong>Dump Java Heap</strong>操作（在<strong>Memory</strong>的旁边，从左边数起第三个图标）。这将生成一个<strong>HPROF</strong>文件，其中包含我们调用该操作时的一个内存快照。几秒钟后，Android Studio 会自动打开该文件，给我们更易于分析内存的直观表示。</p>
<p>我不会去深入有关如何分析巨大的内存堆。相反，我会把你的注意力引导到 <strong>Analyzer Tasks</strong>（下面截图中的右上角）。为了检测上面的例子中引入的内存泄漏，你所需要做的检测是检查泄露的Activity（<strong>Detect Leaked Activities</strong>），点击播放按钮然后在<strong>Analysis Results</strong>下面就会显示泄露的Activity情况。 </p>
<p><img src="http://ww3.sinaimg.cn/mw690/0063dNt1jw1f6zscmteaaj310t0kd7c5.jpg" alt="Paste_Image.png"></p>
<p>如果我们选中泄露的Activity，可以得到一个引用树，该引用树可以检测持有该Activity的引用。通过寻找深度为零的实例，我们发现位置管理器中的实例<strong>mListener</strong>，是我们的Activity不能被GC回收的原因。回到我们的代码，我们可以看到，这个引用是由于我们在<strong>requestLocationsUpdates</strong>方法中设置Activity作为位置更新回调导致的。通过阅读<a href="https://developer.android.com/reference/android/location/LocationManager.html" target="_blank" rel="external">位置管理器文档</a>，问题很快变得清晰，为了取消回调设置，我们简单地调用<strong>removeUpdates</strong>方法就行了。在我们的例子，因为我们注册更新是在<strong>onCreate</strong>方法，显然要注销的地方在<strong>onDestroy</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaksActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LocationListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> LocationManager locationManager;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_leaks);</div><div class="line">        locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);</div><div class="line">        locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER,</div><div class="line">                TimeUnit.MINUTES.toMillis(<span class="number">5</span>), <span class="number">100</span>, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        locationManager.removeUpdates(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Listener implementation omitted</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重新构建程序并执行与上述相同的内存分析，无论旋转多少次设备，应该都不会导致Activity泄漏。</p>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>内部类在Java中是一个很常见的数据结构。它们很受欢迎，因为它们可以以这样的方式来定义：即只有外部类可以实例化它们。很多人可能没有意识到的是这样的类会持有外部类的隐式引用。隐式引用很容易出错，尤其是当两个类具有不同的生命周期。以下是常见的Android Activity写法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    TextView textView;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_async);</div><div class="line">        textView = (TextView) findViewById(R.id.textView);</div><div class="line"></div><div class="line">        <span class="keyword">new</span> BackgroundTask().execute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</div><div class="line">            <span class="comment">// Do background work. Code omitted.</span></div><div class="line">            <span class="keyword">return</span> <span class="string">"some string"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">            textView.setText(result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种特殊的实现在执行上没有问题。问题是，它保留内存的时间肯定会超过必要的时间。由于<strong>BackgroundTask</strong>持有一个<strong>AsyncActivity</strong>隐式引用并运行在另一个没有取消策略的线程上，它将保留AsyncActivity在内存中的所有资源连接，直到后台线程终止运行。在HTTP请求的情况下，这可能需要很长的时间，尤其是在速度较慢的连接。</p>
<p>通过执行相同的步骤，如同前面的示例，并确保长时间运行的后台任务，我们最终会得到下面的分析结果。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/0063dNt1jw1f6zscmy9rvj30xd0if126.jpg" alt="Paste_Image.png"></p>
<p>从上面的分析中可以看出，<strong>BackgroundTask</strong> 确实是这种内存泄漏的罪魁祸首。我们第一要务是使用静态类的实现方式来消除指向Activity的引用，但这样我们也不能直接访问 textView 了。因此我们还需要添加一个构造函数，把textView作为参数传递进来。最后，我们需要引入<a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask文档</a>中所述的取消策略。考虑到所有这一切，让我们看看我们的代码最终呈现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    TextView textView;</div><div class="line">    AsyncTask task;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_async);</div><div class="line">        textView = (TextView) findViewById(R.id.textView);</div><div class="line"></div><div class="line">        task = <span class="keyword">new</span> BackgroundTask(textView).execute();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        task.cancel(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TextView resultTextView;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BackgroundTask</span><span class="params">(TextView resultTextView)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.resultTextView = resultTextView;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// Cancel task. Code omitted.</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</div><div class="line">            <span class="comment">// Do background work. Code omitted.</span></div><div class="line">            <span class="keyword">return</span> <span class="string">"some string"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">            resultTextView.setText(result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，隐式引用已被消除，我们通过构造函数传递相关实例，并在合适的地方取消任务。让我们再运行分析任务，看看这种改变是否消除了内存泄漏。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/0063dNt1jw1f6zscmdtifj30xd0if11s.jpg" alt="Paste_Image.png"></p>
<p>看来我们还有一些工作要做。根据前一个例子的经验，我们可以知道在引用树中高亮标注的实例导致了Activity泄露。那么这是什么回事？我们看一下它的父节点就可以发现resultTextView持有一个<strong>mContext</strong>引用，毫无疑问，它就是泄露的Activity的引用。那么如何解决这个问题？我们无法消除resultTextView绑定的context引用，因为我们需要在<strong>BackgroundTask</strong>中使用resultTextView的引用，以便更新用户界面。为了解决这个问题，一种简单的方法是使用<a href="https://developer.android.com/reference/java/lang/ref/WeakReference.html" target="_blank" rel="external"><strong>WeakReference</strong></a>。我们持有的<strong>resultTextView</strong>引用是强引用，具有防止GC回收的能力。相反，<strong>WeakReference</strong>不保证其引用的实例存活。当一个实例最后一个强引用被删除，GC会把其资源回收，而不管这个实例是否有弱引用。下面是使用WeakReference的最终版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    TextView textView;</div><div class="line">    AsyncTask task;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_async);</div><div class="line">        textView = (TextView) findViewById(R.id.textView);</div><div class="line"></div><div class="line">        task = <span class="keyword">new</span> BackgroundTask(textView).execute();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        task.cancel(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;TextView&gt; textViewReference;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BackgroundTask</span><span class="params">(TextView resultTextView)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.textViewReference = <span class="keyword">new</span> WeakReference&lt;&gt;(resultTextView);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// Cancel task. Code omitted.</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</div><div class="line">            <span class="comment">// Do background work. Code omitted.</span></div><div class="line">            <span class="keyword">return</span> <span class="string">"some string"</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">            TextView view = textViewReference.get();</div><div class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                view.setText(result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意，在<strong>onPostExecute</strong>我们要检查空值，判断实例是否被回收。</p>
<p>最后，再一次运行分析器任务，确认我们的Activity不再被泄露 ！</p>
<h4 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h4><p>这种类型的类和内部类有同样的缺点，即他们持有外部类的引用。如同内部类，一个匿名类在Activity生命周期之外执行或在其他线程执行工作时，可能会导致内存泄漏。在这个例子中，我将使用流行的HTTP请求库<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a>执行API调用，并传递响应给对应回调。根据<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit homepage</a>上面例子对Retrofit进行配置。我会在Application中持有<strong>GitHubService</strong>引用，这不是一个特别好的设计，这仅仅服务于这个例子的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    TextView textView;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_listener);</div><div class="line">        textView = (TextView) findViewById(R.id.textView);</div><div class="line"></div><div class="line">        GitHubService service = ((LeaksApplication) getApplication()).getService();</div><div class="line">        service.listRepos(<span class="string">"google"</span>)</div><div class="line">                .enqueue(<span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call,</span></span></div><div class="line">                                           Response&lt;List&lt;Repo&gt;&gt; response) &#123;</div><div class="line">                        <span class="keyword">int</span> numberOfRepos = response.body().size();</div><div class="line">                        textView.setText(String.valueOf(numberOfRepos));</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t)</span> </span>&#123;</div><div class="line">                        <span class="comment">// Code omitted.</span></div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是常见的解决方案，不应该导致任何泄漏。但是，如果我们在慢速连接中执行这个例子，分析结果会有所不同。请记住，直到该线程终止，该Activity会一直被持有，就像在内部类的例子。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/0063dNt1jw1f6zscn7huij311l0l3qb4.jpg" alt="Paste_Image.png"></p>
<p> 根据在内部类的例子中同样的推理，我们得出一个结论：匿名回调类是内存泄漏的原因。然而，正如内部类的例子，此代码包含两个问题。首先，请求没有取消策略。其次，需要消除对Activity的隐式引用。明显的解决办法：我们在内部类的例子做了同样的事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    TextView textView;</div><div class="line">    Call call;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_listener);</div><div class="line">        textView = (TextView) findViewById(R.id.textView);</div><div class="line"></div><div class="line">        GitHubService service = ((LeaksApplication) getApplication()).getService();</div><div class="line">        call = service.listRepos(<span class="string">"google"</span>);</div><div class="line">        call.enqueue(<span class="keyword">new</span> RepoCallback(textView));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        call.cancel();</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RepoCallback</span> <span class="keyword">implements</span> <span class="title">Callback</span>&lt;<span class="title">List</span>&lt;<span class="title">Repo</span>&gt;&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;TextView&gt; resultTextView;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RepoCallback</span><span class="params">(TextView resultTextView)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.resultTextView = <span class="keyword">new</span> WeakReference&lt;&gt;(resultTextView);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call,</span></span></div><div class="line">                Response&lt;List&lt;Repo&gt;&gt; response) &#123;</div><div class="line">            TextView view = resultTextView.get();</div><div class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">int</span> numberOfRepos = response.body().size();</div><div class="line">                view.setText(String.valueOf(numberOfRepos));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t)</span> </span>&#123;</div><div class="line">            <span class="comment">// Code omitted.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据上述解决方案，运行分析任务，将不会再有Activity的泄露。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>后台任务独立于Activity的生命周期运行是一件麻烦事。再加上需要协调用户界面和各种后台任务之间的数据流，如果你不小心，那将是一个灾难。所以要知道你在做什么，以及你的代码是否对性能有影响。这些基本准则是处理Activity的良好开端：</p>
<ul>
<li><strong>尽量使用静态内部类。</strong>每个非静态内部类将持有一个外部类的隐式引用，这可能会导致不必要的问题。使用静态内部类代替非静态内部类，并通过弱引用存储一些必要的生命周期引用。</li>
<li><strong>考虑后台服务等手段，</strong> Android提供了多种在非主线程工作的方法，如<strong>HandlerThread</strong>，<strong>IntentService</strong>和<strong>AsyncTask</strong>，它们每个都有自己的优缺点。另外，Android提供了一些机制来传递信息给主线程以更新UI。譬如，<strong>广播接收器</strong>就可以很方便实现这一点。</li>
<li><strong>不要一味依赖垃圾回收器。</strong>使用具有垃圾回收功能的语言编码很容易有这样的想法：即没必要考虑内存管理。我们的示例清楚地表明，并非如此。因此，请确保你分配的资源都被预期回收。</li>
</ul>
<h4 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://medium.com/freenet-engineering/memory-leaks-in-android-identify-treat-and-avoid-d0b1233acc8#.9r06xyg05" target="_blank" rel="external">原文链接</a></h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为开发人员，在我们的日常开发中，为了构建更好的应用程序，我们需要考虑很多事情以保证应用运行在正轨上，其中之一是要确保我们的应用程序不会崩溃。应用崩溃的一个常见原因是内存泄漏。这方面的问题可以以各种形式表现出来。在大多数情况下，我们看到内存使用率稳步上升，直到应用程序不能分配更多的资源，并不可避免地崩溃。在Java中这往往导致一个&lt;strong&gt;OutOfMemoryException异常&lt;/strong&gt;被抛出。在某些罕见的情况下，泄露的类甚至可以逗留很长时间来接收已注册的回调，这会导致一些非常奇怪的错误，并往往抛出臭名昭著的&lt;strong&gt;IllegalStateException异常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了帮助他人在代码分析上减少花费时间，我将介绍内存泄漏的几个例子，阐述在Android Studio中如何检查它们，当然最重要的是如何将其解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ZeusPlugin:掌阅Android App插件补丁实践</title>
    <link href="http://yoursite.com/2016/08/20/ZeusPlugin-%E6%8E%8C%E9%98%85Android-App%E6%8F%92%E4%BB%B6%E8%A1%A5%E4%B8%81%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2016/08/20/ZeusPlugin-掌阅Android-App插件补丁实践/</id>
    <published>2016-08-19T18:46:27.000Z</published>
    <updated>2016-08-19T22:02:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><ul>
<li><p>65K方法数超限</p>
<p>随着应用不断迭代，业务线的扩展,应用越来越大，那么很不幸，总有一天，当你编译的时候，会遇到一个类似下面的错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Conversion to Dalvik format failed: Unable to execute dex: method ID not in [<span class="number">0</span>, <span class="number">0xffff</span>]: <span class="number">65536</span></div></pre></td></tr></table></figure>
<p>没错，这就是臭名昭著的65536方法数超限问题。具体原理可以参考<a href="http://jayfeng.com/2016/03/10/%E7%94%B1Android-65K%E6%96%B9%E6%B3%95%E6%95%B0%E9%99%90%E5%88%B6%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/" target="_blank" rel="external">由Android 65K方法数限制引发的思考</a>这篇文章。当然，google也意识到这个问题，所以发布了MultiDex支持库。喜大普奔，赶紧使用，问题解决？Too Young ! 使用过程中，你会发现MultiDex有不少坑：启动时间过长、ANR/Crash。当然也有解决方法，可以参考<a href="http://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="external">美团自动拆包方案</a>。但我只想说真的太….麻烦了，还能不能愉快地回家玩游戏了….</p>
<a id="more"></a></li>
<li><p>上线太慢，更新率太低</p>
<p>总所周知，Android APP发布流程较为漫长，一般需要经历<code>开发完成—上传市场—审核—上线</code>几个阶段，而且各个市场都各有各的政策和审核速度，每发一版都是一次煎熬呀。再者，Android APP的升级率跟Android系统升级率一样，怎一个慢字了得。新版本要覆盖80%左右，怎么也需要两周左右。</p>
</li>
<li><p>一上线就如临大敌</p>
<p>以为应用上线就完事了？NO ！相信大部分开发同学在应用上线的头一周都是过得提心吊胆的，祈祷着不要出bug，用户不要反馈问题。但往往事与愿违，怎么办，赶紧出hotfix版本？</p>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>就不卖关子了，是的，我们的解决方案是构建一套插件补丁的方案，期望可以无痛解决以上问题。插件化和补丁在目前看来是老生常谈的东西了，市面上已经有一堆实现方案，如<a href="https://github.com/Qihoo360/DroidPlugin" target="_blank" rel="external">DroidPlugin</a>、<a href="https://github.com/wequick/Small" target="_blank" rel="external">Small</a>、<a href="https://github.com/limpoxe/Android-Plugin-Framework" target="_blank" rel="external">Android-Plugin-Framework</a>。掌阅研究插件化是从2014年中开始，研究补丁是从2016年初开始，相对来说，算是比较晚。直至目前，插件化方案已经达到相对成熟的阶段，而补丁方案也已经上线。秉着开源的精神，我们的插件补丁方案最近已经在Github开源— <a href="https://github.com/iReaderAndroid/ZeusPlugin" target="_blank" rel="external">ZeusPlugin</a>。相对其他插件化和热修复方案，ZeusPlugin最大特点是：<strong>简单易懂，核心类只有6个，类总数只有13个</strong>，我们期望开发同学在使用这套方案的同时能理解所有的实现细节，在我们看来，这确实不是什么晦涩难懂的东西。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>要实现插件补丁，其实无非就是要解决几个问题：<strong>插件安装、资源加载和类加载</strong>。这几点，我们可以参考Android系统加载APK的实现原理。</p>
<h4 id="Android系统加载APK"><a href="#Android系统加载APK" class="headerlink" title="Android系统加载APK"></a>Android系统加载APK</h4><ul>
<li><p><strong>APK安装过程</strong></p>
<ol>
<li><p>复制APK安装包到data/app临时目录下，如<code>vmdl648417937.tmp/base.apk</code>；</p>
</li>
<li><p>解析应用程序的配置文件<code>AndroidManifest.xml</code>；</p>
</li>
<li><p>进行Dexopt并生成ODEX,如<code>vmdl648417937.tmp/oat/arm/base.odex</code>；</p>
</li>
<li><p>将临时目录(vmdl648417937.tmp)重命名为<code>packageName + &quot;-&quot; + suffix</code>,如<code>com.test_1</code>；</p>
</li>
<li><p>在PackageManagerService中将上述步骤生成的apk信息通过mPackages成员变量缓存起来；</p>
<blockquote>
<p>mPackages是个ArrayMap，key为包名，value为<a href="https://android.googlesource.com/platform/frameworks/base/+/56a2301/core/java/android/content/pm/PackageParser.java" target="_blank" rel="external">PackageParser.Package</a>(apk包信息)</p>
</blockquote>
</li>
<li><p>在data/data目录下创建对应的应用数据目录。</p>
</li>
</ol>
</li>
<li><p><strong>启动APK过程</strong></p>
<ol>
<li>点击桌面App图标，Launcher接收到点击事件，获取应用信息，通过Binder IPC向SystemService进程(即system_process)发起startActivity请求(ActivityManagerService(AMS)#startActivity)；</li>
<li>SystemServer(AMS) 向zygote进程请求启动一个新进程（ActivityManagerService#startProcessLocked）；</li>
<li>Zygote进程fork出新的子进程(APP进程)，在新进程中执行 ActivityThread 类的 main 方法；</li>
<li>App进程创建ActivityThread实例，并通过Binder IPC向 SystemServer(AMS) 请求 attach 到 AMS;</li>
<li>SystemServer(AMS) 进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送<code>bindApplication</code>和<code>scheduleLaunchActivity</code>请求；</li>
<li>App进程(ActivityThread）在收到<code>bindApplication</code>请求后，通过handler向主线程发送<code>BIND_APPLICATION</code>消息；</li>
<li>主线程在收到<code>BIND_APPLICATION</code>消息后,根据传递过来的ApplicationInfo创建一个对应的LoadApk对象(标志当前APK信息),然后创建ContextImpl对象(标志当前进程的环境)，紧接着通过反射创建目标Application，并调用其attach方法，将ContextImpl对象设置为目标Application的上下文环境，最后调用Application的onCreate函数，做一些初始工作；</li>
<li>App进程(ApplicationThread）在收到<code>scheduleLaunchActivity</code>请求后，通过handler向主线程发送<code>LAUNCH_ACTIVITY</code>消息；</li>
<li>主线程在收到<code>LAUNCH_ACTIVITY</code>消息后，通过反射机制创建目标Activity，并调用Activity的onCreate()方法。</li>
</ol>
</li>
</ul>
<p>以上分析都是基于Android 6.0的源码，其他版本可能有少许差异，但不影响主流程，限于篇幅问题，在此不一一展开分析，只重点分析相关的关键几个步骤。</p>
<p>为什么提到<strong>Android系统加载APK</strong>的流程，因为分析完<strong>Android系统加载APK</strong>的流程，插件补丁方案也就基本能实现出来了，下面我展开说一下。</p>
<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>从APK安装过程分析得知</p>
<ol>
<li><strong>配置文件<code>AndroidManifest.xml</code>是在应用安装时就已经解析并记录，所以插件的AndroidManifest.xml配置无法生效</strong></li>
<li><strong>每个APK安装都是独享空间的，不同APK、同一个APK的不同时间安装都是完全独立的</strong>。这样做，个人觉得大大降低了系统的复杂度，而且清晰明了。在这点上， <a href="https://github.com/iReaderAndroid/ZeusPlugin" target="_blank" rel="external">ZeusPlugin</a>插件安装策略几乎就是仿照系统设计的。具体可以参考 <a href="https://github.com/iReaderAndroid/ZeusPlugin" target="_blank" rel="external">ZeusPlugin</a>源码，在此不展开描述。</li>
</ol>
<h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><p>   从上述启动APK过程分析7、9可以得知，Application和Activity都是通过反射机制创建的，我们可以看看Application创建具体源码实现：</p>
<p>   ActivityThread#handleBindApplication</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</div><div class="line">         	......</div><div class="line">             <span class="comment">//省略代码</span></div><div class="line">   	    .......</div><div class="line">             <span class="comment">//生成APK信息LoadedApk，即packageInfo</span></div><div class="line">           data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</div><div class="line">      		 <span class="comment">//创建上下文环境</span></div><div class="line">           <span class="keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="keyword">this</span>, data.info);</div><div class="line">    		......</div><div class="line">             <span class="comment">//省略代码</span></div><div class="line">   	    .......</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               <span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></div><div class="line">               <span class="comment">// a restricted environment with the base application class.</span></div><div class="line">             	<span class="comment">//通过反射机制创建Application实例</span></div><div class="line">               Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</div><div class="line">               mInitialApplication = app;</div><div class="line"></div><div class="line">           	......</div><div class="line">             	<span class="comment">//省略代码</span></div><div class="line">   	   		 .......</div><div class="line"></div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                  	<span class="comment">//调用Application onCreate方法·</span></div><div class="line">                   mInstrumentation.callApplicationOnCreate(app);</div><div class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                   <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</div><div class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                           <span class="string">"Unable to create application "</span> + app.getClass().getName()</div><div class="line">+ <span class="string">": "</span> + e.toString(), e);</div><div class="line">                         &#125;</div><div class="line">          &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          StrictMode.setThreadPolicy(savedPolicy);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>  我们再看看<code>LoadedApk#makeApplication</code>的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span></span></div><div class="line">           Instrumentation instrumentation) &#123;</div><div class="line">       <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> mApplication;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       Application app = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">       String appClass = mApplicationInfo.className;</div><div class="line">       <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="keyword">null</span>)) &#123;</div><div class="line">           appClass = <span class="string">"android.app.Application"</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">         	<span class="comment">//获取ClassLoader</span></div><div class="line">           java.lang.ClassLoader cl = getClassLoader();</div><div class="line">           <span class="keyword">if</span> (!mPackageName.equals(<span class="string">"android"</span>)) &#123;</div><div class="line">               initializeJavaContextClassLoader();</div><div class="line">           &#125;</div><div class="line">           ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</div><div class="line">           <span class="comment">//使用获取到的ClassLoader通过反射机制创建Application实例，其内部实现是通过		ClassLoader.loadClass(className)得到Application Class</span></div><div class="line">           app = mActivityThread.mInstrumentation.newApplication(</div><div class="line">                   cl, appClass, appContext);</div><div class="line">           appContext.setOuterContext(app);</div><div class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">           <span class="keyword">if</span> (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                   <span class="string">"Unable to instantiate application "</span> + appClass</div><div class="line">                   + <span class="string">": "</span> + e.toString(), e);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       mActivityThread.mAllApplications.add(app);</div><div class="line">       mApplication = app;</div><div class="line"></div><div class="line">      ......</div><div class="line">       <span class="comment">//省略代码</span></div><div class="line">   .......</div><div class="line"></div><div class="line">       <span class="keyword">return</span> app;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>  从上述代码可以得知，系统加载Application时候是先获取一个特定ClassLoader，然后该ClassLoader通过反射机制创建Application实例。我们继续看看getClassLoader()的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mClassLoader != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> mClassLoader;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mIncludeCode &amp;&amp; !mPackageName.equals(<span class="string">"android"</span>)) &#123;</div><div class="line">                ......</div><div class="line">       		 <span class="comment">//省略代码</span></div><div class="line">	 		  .......</div><div class="line">			   <span class="comment">//创建ClassLoader</span></div><div class="line">                mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib,</div><div class="line">                        mBaseClassLoader);</div><div class="line"></div><div class="line">                StrictMode.setThreadPolicy(oldPolicy);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (mBaseClassLoader == <span class="keyword">null</span>) &#123;</div><div class="line">                    mClassLoader = ClassLoader.getSystemClassLoader();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    mClassLoader = mBaseClassLoader;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> mClassLoader;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>  继续跟踪ApplicationLoaders类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">(String zip, String libPath, ClassLoader parent)</span></span></div><div class="line">&#123;</div><div class="line">  </div><div class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (mLoaders) &#123;</div><div class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</div><div class="line">            parent = baseParent;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * If we're one step up from the base class loader, find</div><div class="line">         * something in our cache.  Otherwise, we create a whole</div><div class="line">         * new ClassLoader for the zip archive.</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (parent == baseParent) &#123;</div><div class="line">            ClassLoader loader = mLoaders.get(zip);</div><div class="line">            <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> loader;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</div><div class="line">          </div><div class="line">            PathClassLoader pathClassloader =</div><div class="line">                <span class="keyword">new</span> PathClassLoader(zip, libPath, parent);</div><div class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">  		</div><div class="line">            mLoaders.put(zip, pathClassloader);</div><div class="line">            <span class="keyword">return</span> pathClassloader;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</div><div class="line">        PathClassLoader pathClassloader = <span class="keyword">new</span> PathClassLoader(zip, parent);</div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">        <span class="keyword">return</span> pathClassloader;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> ApplicationLoaders是一个静态缓存工具类，其内部维护了一个key为dexPath，value为PathClassLoader的ArrayMap，可以看到，应用程序使用的ClassLoader都是同一个PathClassLoader类的实例</p>
<p> 我们继续扒一扒PathClassLoader的源码，发现其实现都在父类<a href="https://android.googlesource.com/platform/libcore-snapshot/+/ics-mr1/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="external">BaseDexClassLoader</a>中，我们直接找到其<code>findClass</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</div><div class="line">        Class c = pathList.findClass(name, suppressedExceptions);</div><div class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</div><div class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</div><div class="line">                cnfe.addSuppressed(t);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> cnfe;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>  可以看到，查找Class的任务通其内部一个<code>DexPathList</code>类对象实现的，它的<code>findClass</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</div><div class="line">       <span class="keyword">for</span> (Element element : dexElements) &#123;</div><div class="line">           DexFile dex = element.dexFile;</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</div><div class="line">               Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</div><div class="line">               <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">return</span> clazz;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</div><div class="line">           suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>至此，真相大白，原来，APK类加载是通过遍历<code>dexElements</code>这个数组来查找Class，而dexElements就是APK dexPath里面的文件。</p>
<p>从上述分析可以得知要实现插件的类加载有两种方式：</p>
<ol>
<li><strong>把插件的信息通过反射放进这个数组里面</strong></li>
<li><p><strong>替换系统的ClassLoader</strong></p>
<p>考虑到类的隔离性以及框架拓展性，<a href="https://github.com/iReaderAndroid/ZeusPlugin" target="_blank" rel="external">ZeusPlugin</a>目前使用的方案是第二种，根据类加载器的双亲委派模型，我们可以实现一套插件补丁类加载方案，如下图：</p>
</li>
</ol>
<p><img src="http://ww4.sinaimg.cn/mw690/0063dNt1jw1f6zsc3wnlyj30qo0k0jru.jpg" alt="类加载.jpg"></p>
<blockquote>
<ol>
<li>我们通过反射修改系统的ClassLoader为ZeusClassLoader，其内包含多个ZeusPluginClassLoader</li>
<li>每一个插件对应一个ZeusPluginClassLoader，当移除插件时则删除一个ZeusPluginClassLoader，加载一个插件则添加一个ZeusPluginClassLoader，</li>
<li>ZeusClassLoader的parent为原始APK的ClassLoader(PathClassLoader)，而原始APK的ClassLoader的parent(PathClassLoader)为ZeusHotfixClassLoader, ZeusHotfixClassLoader的parent为系统的ClassLoader(BootClassLoader)。</li>
</ol>
</blockquote>
<h4 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h4><p>  关于资源加载，我们回到<code>handleBindApplication</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</div><div class="line">      	......</div><div class="line">          <span class="comment">//省略代码</span></div><div class="line">	    .......</div><div class="line">          <span class="comment">//生成APK信息LoadedApk，即packageInfo</span></div><div class="line">        data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</div><div class="line">   		 <span class="comment">//创建上下文环境</span></div><div class="line">        <span class="keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="keyword">this</span>, data.info);</div><div class="line"> 		......</div><div class="line">          <span class="comment">//省略代码</span></div><div class="line">	    .......</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 这里创建了上下文环境，即ContextImpl，再看看createAppContext方法真正实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ContextImpl</span><span class="params">(ContextImpl container, ActivityThread mainThread,</span></span></div><div class="line">            LoadedApk packageInfo, IBinder activityToken, UserHandle user, <span class="keyword">boolean</span> restricted,</div><div class="line">            Display display, Configuration overrideConfiguration, <span class="keyword">int</span> createDisplayWithId) &#123;</div><div class="line">        ......</div><div class="line">          <span class="comment">//省略代码</span></div><div class="line">	    .......</div><div class="line">		<span class="comment">//真正创建Resources的地方</span></div><div class="line">        Resources resources = packageInfo.getResources(mainThread);</div><div class="line">        <span class="keyword">if</span> (resources != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (displayId != Display.DEFAULT_DISPLAY</div><div class="line">                    || overrideConfiguration != <span class="keyword">null</span></div><div class="line">                    || (compatInfo != <span class="keyword">null</span> &amp;&amp; compatInfo.applicationScale</div><div class="line">                            != resources.getCompatibilityInfo().applicationScale)) &#123;</div><div class="line">                resources = mResourcesManager.getTopLevelResources(packageInfo.getResDir(),</div><div class="line">                        packageInfo.getSplitResDirs(), packageInfo.getOverlayDirs(),</div><div class="line">                        packageInfo.getApplicationInfo().sharedLibraryFiles, displayId,</div><div class="line">                        overrideConfiguration, compatInfo);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        mResources = resources;</div><div class="line">		......</div><div class="line">          <span class="comment">//省略代码</span></div><div class="line">	    .......</div><div class="line">     </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p> <code>Resources resources = packageInfo.getResources(mainThread);</code>这段代码就是真正创建Resources的地方，我们继续跟进去会发现它最终调用的是ResourcesManager的getTopLevelResources方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function">Resources <span class="title">getTopLevelResources</span><span class="params">(String resDir, String[] splitResDirs,</span></span></div><div class="line">           String[] overlayDirs, String[] libDirs, <span class="keyword">int</span> displayId,</div><div class="line">           Configuration overrideConfiguration, CompatibilityInfo compatInfo) &#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">float</span> scale = compatInfo.applicationScale;</div><div class="line">       Configuration overrideConfigCopy = (overrideConfiguration != <span class="keyword">null</span>)</div><div class="line">               ? <span class="keyword">new</span> Configuration(overrideConfiguration) : <span class="keyword">null</span>;</div><div class="line">       ResourcesKey key = <span class="keyword">new</span> ResourcesKey(resDir, displayId, overrideConfigCopy, scale);</div><div class="line">       Resources r;</div><div class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">           <span class="comment">// Resources is app scale dependent.</span></div><div class="line">           <span class="keyword">if</span> (DEBUG) Slog.w(TAG, <span class="string">"getTopLevelResources: "</span> + resDir + <span class="string">" / "</span> + scale);</div><div class="line">	   <span class="comment">//判断是否已经存在Resources</span></div><div class="line">           WeakReference&lt;Resources&gt; wr = mActiveResources.get(key);</div><div class="line">           r = wr != <span class="keyword">null</span> ? wr.get() : <span class="keyword">null</span>;</div><div class="line">           <span class="comment">//if (r != null) Log.i(TAG, "isUpToDate " + resDir + ": " + r.getAssets().isUpToDate());</span></div><div class="line">           <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; r.getAssets().isUpToDate()) &#123;</div><div class="line">               <span class="keyword">if</span> (DEBUG) Slog.w(TAG, <span class="string">"Returning cached resources "</span> + r + <span class="string">" "</span> + resDir</div><div class="line">                       + <span class="string">": appScale="</span> + r.getCompatibilityInfo().applicationScale</div><div class="line">                       + <span class="string">" key="</span> + key + <span class="string">" overrideConfig="</span> + overrideConfiguration);</div><div class="line">               <span class="keyword">return</span> r;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">//if (r != null) &#123;</span></div><div class="line">       <span class="comment">//    Log.w(TAG, "Throwing away out-of-date resources!!!! "</span></div><div class="line">       <span class="comment">//            + r + " " + resDir);</span></div><div class="line">       <span class="comment">//&#125;</span></div><div class="line">	<span class="comment">//创建资源管理器</span></div><div class="line">       AssetManager assets = <span class="keyword">new</span> AssetManager();</div><div class="line">       <span class="comment">// resDir can be null if the 'android' package is creating a new Resources object.</span></div><div class="line">       <span class="comment">// This is fine, since each AssetManager automatically loads the 'android' package</span></div><div class="line">       <span class="comment">// already.</span></div><div class="line">       <span class="keyword">if</span> (resDir != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="comment">//添加APK资源路径</span></div><div class="line">           <span class="keyword">if</span> (assets.addAssetPath(resDir) == <span class="number">0</span>) &#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    ......</div><div class="line">         <span class="comment">//省略代码</span></div><div class="line">    .......</div><div class="line">       <span class="comment">//创建Resources</span></div><div class="line">       r = <span class="keyword">new</span> Resources(assets, dm, config, compatInfo);</div><div class="line">       <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"Created app resources "</span> + resDir + <span class="string">" "</span> + r + <span class="string">": "</span></div><div class="line">               + r.getConfiguration() + <span class="string">" appScale="</span> + r.getCompatibilityInfo().applicationScale);</div><div class="line"></div><div class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">           WeakReference&lt;Resources&gt; wr = mActiveResources.get(key);</div><div class="line">           Resources existing = wr != <span class="keyword">null</span> ? wr.get() : <span class="keyword">null</span>;</div><div class="line">           <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; existing.getAssets().isUpToDate()) &#123;</div><div class="line">               <span class="comment">// Someone else already created the resources while we were</span></div><div class="line">               <span class="comment">// unlocked; go ahead and use theirs.</span></div><div class="line">               r.getAssets().close();</div><div class="line">               <span class="keyword">return</span> existing;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// XXX need to remove entries when weak references go away</span></div><div class="line">           mActiveResources.put(key, <span class="keyword">new</span> WeakReference&lt;&gt;(r));</div><div class="line">           <span class="keyword">if</span> (DEBUG) Slog.v(TAG, <span class="string">"mActiveResources.size()="</span> + mActiveResources.size());</div><div class="line">           <span class="keyword">return</span> r;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p> 至此，Resources就创建好了，这里有一个关键的类AssetManager，它是应用程序的资源管理器，在它的构造函数里会把<code>framework/framework-res.apk</code>也会添加到资源路径中，这是C++调用，有兴趣的话，可以参考一下老罗<a href="http://blog.csdn.net/luoshengyang/article/details/8791064" target="_blank" rel="external">这篇文章</a>。同时这也解释了为什么我们开发的应用可以访问到系统的资源。</p>
<p> 通过上述分析，我们可以得知，要实现插件资源加载，只需<strong>创建一个<code>AssetManager</code>,然后把把宿主资源路径和插件apk路径添加进去，创建我们自己的Resources，然后通过反射把PackageInfo的<code>mResources</code>替换成我们的Resources</strong>即可，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">AssetManager assetManager = AssetManager.class.newInstance();</div><div class="line">           Method addAssetPath = AssetManager.class.getMethod(<span class="string">"addAssetPath"</span>, String.class);</div><div class="line">           addAssetPath.invoke(assetManager, mBaseContext.getPackageResourcePath());</div><div class="line">           <span class="keyword">if</span> (mLoadedPluginList != <span class="keyword">null</span> &amp;&amp; mLoadedPluginList.size() != <span class="number">0</span>) &#123;</div><div class="line">               <span class="comment">//每个插件的packageID都不能一样</span></div><div class="line">               <span class="keyword">for</span> (String id : mLoadedPluginList.keySet()) &#123;</div><div class="line">                   addAssetPath.invoke(assetManager, PluginUtil.getAPKPath(id));</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">//这里提前创建一个resource是因为Resources的构造函数会对AssetManager进行一些变量的初始化</span></div><div class="line">           <span class="comment">//还不能创建系统的Resources类，否则中兴系统会出现崩溃问题</span></div><div class="line">           PluginResources newResources = <span class="keyword">new</span> PluginResources(assetManager,</div><div class="line">                   mBaseContext.getResources().getDisplayMetrics(),</div><div class="line">                   mBaseContext.getResources().getConfiguration());</div><div class="line"></div><div class="line"></div><div class="line">           PluginUtil.setField(mBaseContext, <span class="string">"mResources"</span>, newResources);</div><div class="line">           <span class="comment">//这是最主要的需要替换的，如果不支持插件运行时更新，只留这一个就可以了</span></div><div class="line">           PluginUtil.setField(mPackageInfo, <span class="string">"mResources"</span>, newResources);</div></pre></td></tr></table></figure>
<p>现在，参考以上思路，我们已经基本可以实现一个插件补丁框架，其实站在巨人的肩膀(Android 系统源码)上，是不是觉得实现一套插件补丁框架也没那么复杂呢？当然，真正项目中，还有很多细节需要处理，譬如说资源分区、代码混淆等问题。但核心逻辑基本还是以上这些思路。具体实现可以参考 <a href="https://github.com/iReaderAndroid/ZeusPlugin" target="_blank" rel="external">ZeusPlugin</a>源码</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>由于公司业务线、时间精力等原因， <a href="https://github.com/iReaderAndroid/ZeusPlugin" target="_blank" rel="external">ZeusPlugin</a>有一些特性和功能还没实现，但很多也提上日程了，比如：</p>
<ul>
<li><p>demo完善</p>
</li>
<li><p>gradle插件maven远程依赖</p>
</li>
<li><p>支持补丁更换资源</p>
<p>……..</p>
</li>
</ul>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p><a href="https://github.com/iReaderAndroid/ZeusPlugin" target="_blank" rel="external">https://github.com/iReaderAndroid/ZeusPlugin</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;遇到问题&quot;&gt;&lt;a href=&quot;#遇到问题&quot; class=&quot;headerlink&quot; title=&quot;遇到问题&quot;&gt;&lt;/a&gt;遇到问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;65K方法数超限&lt;/p&gt;
&lt;p&gt;随着应用不断迭代，业务线的扩展,应用越来越大，那么很不幸，总有一天，当你编译的时候，会遇到一个类似下面的错误：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Conversion to Dalvik format failed: Unable to execute dex: method ID not in [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0xffff&lt;/span&gt;]: &lt;span class=&quot;number&quot;&gt;65536&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;没错，这就是臭名昭著的65536方法数超限问题。具体原理可以参考&lt;a href=&quot;http://jayfeng.com/2016/03/10/%E7%94%B1Android-65K%E6%96%B9%E6%B3%95%E6%95%B0%E9%99%90%E5%88%B6%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/&quot;&gt;由Android 65K方法数限制引发的思考&lt;/a&gt;这篇文章。当然，google也意识到这个问题，所以发布了MultiDex支持库。喜大普奔，赶紧使用，问题解决？Too Young ! 使用过程中，你会发现MultiDex有不少坑：启动时间过长、ANR/Crash。当然也有解决方法，可以参考&lt;a href=&quot;http://tech.meituan.com/mt-android-auto-split-dex.html&quot;&gt;美团自动拆包方案&lt;/a&gt;。但我只想说真的太….麻烦了，还能不能愉快地回家玩游戏了….&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android插件补丁" scheme="http://yoursite.com/tags/Android%E6%8F%92%E4%BB%B6%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
</feed>
